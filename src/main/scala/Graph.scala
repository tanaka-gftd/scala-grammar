/* データ構造の一つである、グラフについての学習 */
/*
  ここでいう「グラフ」とは、「対象」と「対象同士の関係性」を表現するデータ構造のことで、
  対象を頂点(node,vertex)、関係性を辺(edge)で表現する
*/
/*
  グラフの種類
    向き(関係性の方向)の有無で大別：
      •無向グラフ...辺に向きがない(関係性は対等？)
      •有向グラフ...辺に向きがある(関係性が一方通行)

    連結で大別：
      •連結グラフ...全ての頂点が経路で繋がっているグラフ
      •非連結グラフ...経路で繋がっていない頂点が存在するグラフ

    経路で大別：
      •閉路...始点と終点が同じである経路
      •木(ツリー)...閉路を持たないもの

    有向非巡回グラフ(DAG:Directed Acyclic Graph)...有向グラフで、閉路を持たないもの
*/
/*
  「グラフ」をプログラム上で表現する方法：

    •隣接行列
      頂点同士の繋がりを行列で表現するには2重配列を用いる(繋がりがあれば1, なければ0として表現)
      無向グラフの場合は、行列に対称性がある(関係性に向きがないので)
      有向グラフの場合は、2つの対象の繋がりうちの片方を1,もう片方からの繋がりを0にすることで、繋がりの方向性を表現できる。
      この方式では1の代わりに重みの数値を設定することで、重み付きのグラフも表現できる。

      隣接行列の欠点：
      本来存在しない辺(関係性)にも0という値を持つため、 余計なデータを持ってしまう。
      個々のノードを配列の添字で表現するので、ノードを添字に読み替える必要がある。

    •隣接リスト
      隣接リストでは頂点の辺だけをデータとして持つ。
      隣接行列と違い、存在しない辺(関係性)のデータを持たないので、データ量を少なくできる。
      直接頂点をリストの要素として保持するため、隣接行列のようにノードを添字に読み替える必要がない。

     •隣接リストの辺の情報だけに注目した表現方法もあり、その場合は、辺をオブジェクトとし、辺のコレクションで表現する
*/


//グラフの実装例
object Graph {

  //隣接行列の例
  //ノードを添字に置き換えて、ノード間の繋がりを2重配列で表現する
  val matrix: Array[Array[Int]] = Array(
    Array(0,1,1,0,0),
    Array(1,0,0,1,0),
    Array(1,0,0,1,1),
    Array(0,1,1,0,1),
    Array(0,0,1,1,0),
  )

  //隣接リストの例(上記の隣接行列と同様のグラフ)
  // ノード->Seq(繋がっているノード) という感じのエントリーを持つ、Mapを作成する
  val list: Map[Char, Seq[Char]] = Map(
    'A' -> Seq('B', 'C'),
    'B' -> Seq('A', 'D'),
    'C' -> Seq('A', 'D', 'E'),
    'D' -> Seq('B','C','E'),
    'E' -> Seq('C','D')
  )

  //隣接リストの辺の情報だけに着目した表現方法の例(グラフの内容は上2つと同じ)
  //辺をオブジェクトとし、辺のコレクションで表現する方法
  //from,toで関係性の方向性を表現できる
  case class Edge(from: Char, to: Char)  //クラス宣言はobjectの中でもできる

  val edges = Seq(
    //存在する辺(関係性)だけ、Seqで保存する
    Edge('A', 'B'),
    Edge('A', 'C'),
    Edge('B', 'A'),
    Edge('B', 'D'),
    Edge('C', 'A'),
    Edge('C', 'D'),
    Edge('C', 'E'),
    Edge('D', 'B'),
    Edge('D', 'C'),
    Edge('D', 'E'),
    Edge('E', 'C'),
    Edge('E', 'D'),
  )
}
