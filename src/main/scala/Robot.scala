//自分型アノテーション
/*
  Scalaにはクラスやトレイトの中で自分自身の型にアノテーションを記述できる機能がある。
  自分型アノテーションは、オブジェクトで自分自身を表すキーワード this に別名を付ける機能のことで、
  基本コンストラクタの先頭で定義することができる。
  定義には => を使い、左辺に名前を指定し、右辺には何も書かない。名前は何でも構わないが、selfを使うことが多い。

  また、左辺の名前の後に、自分以外の別の「型」を指定することができ、
  名前: 型1 [with 型2 ...] =>
  自分型アノテーションで型 (トレイト) を指定すると、それを継承したことと同じ扱いになる。
  ただし、インスタンスを生成するときに、指定したトレイトをミックスインする必要がある(ミックスインしないとエラー)
  なお、トレイト内で別トレイトを自分型アノテーションで指定すると、インスタンス化が可能となる。

  以下、例
  REPL実行時に、
  trait HelloGreeter extends Greeter {
    def greet(): Unit = println("Hello!")
  }
  ↓
  val r: Robot = new Robot with HelloGreeter
  ↓
  r.start()
  とすることで、Hello! という文字列が表示される。
  Robotトレイトをインスタンス化するにはGreeterトレイトのミックインが必要だが、
  Greeterトレイト > HelloGreeterトレイト > Robotトレイトの順でミックスインされているので、インスタンス化が可能となる。

  なお、
  r.greet()
  はエラーになる。
  なぜなら、Robotトレイトは、自分型アノテーションでGreeterのgreetメソッドがあるトレイトがミックスインされないとインスタンス化できないが、
  Robot型自身がgreetメソッドを持っているわけではないからである。

  Robot2.scalaファイルも参照し、挙動の違いを確認されたし。
*/
trait Greeter {
  def greet(): Unit
}

trait Robot {

  //ここが自分型アノテーションと呼ばれる部分  //任意の名前: 型 =>
  /*
    Robotトレイトにミックスインできるインスタンスは、
    Greeterという型(トレイト)ではなくてはならないということを指定したものとなっている。
    (トレイトの依存関係を設定している)
    Robotトレイトは、Greeterトレイトの実装があるトレイトがミックスインされることによって、
    抽象メソッドだったメソッドに実装が与えられてインスタンス化できるようになる。
  */
  self: Greeter =>

  def start(): Unit = greet()
  override final def toString = "Robot"
}
